import * as i1 from '@angular/common';
import { isPlatformServer, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, Input, EventEmitter, Injector, Output, ViewChild, ViewChildren, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';
import * as i1$1 from '@ngneat/overview';
import { isTemplateRef, isComponent, DynamicViewModule } from '@ngneat/overview';
import { Subject, race, defer } from 'rxjs';
import { filter, tap } from 'rxjs/operators';

const HOT_TOAST_DEFAULT_TIMEOUTS = {
    blank: 4000,
    error: 4000,
    success: 4000,
    loading: 30000,
    warning: 4000,
    info: 4000,
};
const EXIT_ANIMATION_DURATION = 800;
const ENTER_ANIMATION_DURATION = 350;
const HOT_TOAST_MARGIN = 8;

class HotToastRef {
    constructor(toast) {
        this.toast = toast;
        /** Subject for notifying the user that the toast has been closed. */
        this._onClosed = new Subject();
    }
    get data() {
        return this.toast.data;
    }
    set dispose(value) {
        this._dispose = value;
    }
    getToast() {
        return this.toast;
    }
    /**Used for internal purpose
     * Attach ToastRef to container
     */
    appendTo(container) {
        const { dispose, updateMessage, updateToast, afterClosed } = container.addToast(this);
        this.dispose = dispose;
        this.updateMessage = updateMessage;
        this.updateToast = updateToast;
        this.afterClosed = race(this._onClosed.asObservable(), afterClosed);
        return this;
    }
    /**
     * Closes the toast
     *
     * @param [closeData={ dismissedByAction: false }] -
     * Make sure to pass { dismissedByAction: true } when closing from template
     * @memberof HotToastRef
     */
    close(closeData = { dismissedByAction: false }) {
        this._dispose();
        this._onClosed.next({ dismissedByAction: closeData.dismissedByAction, id: this.toast.id });
        this._onClosed.complete();
    }
}

const animate = (element, value) => {
    element.style.animation = value;
};

class AnimatedIconComponent {
}
AnimatedIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: AnimatedIconComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
AnimatedIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: AnimatedIconComponent, selector: "hot-toast-animated-icon", inputs: { iconTheme: "iconTheme" }, ngImport: i0, template: "<div class=\"hot-toast-animated-icon\" [style.color]=\"iconTheme?.primary\">\n  <ng-content></ng-content>\n</div>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: AnimatedIconComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-animated-icon', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"hot-toast-animated-icon\" [style.color]=\"iconTheme?.primary\">\n  <ng-content></ng-content>\n</div>\n" }]
        }], propDecorators: { iconTheme: [{
                type: Input
            }] } });

class CheckMarkComponent {
}
CheckMarkComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: CheckMarkComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
CheckMarkComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: CheckMarkComponent, selector: "hot-toast-checkmark", inputs: { theme: "theme" }, ngImport: i0, template: "<div\n  class=\"hot-toast-checkmark-icon\"\n  [style.--check-primary]=\"theme?.primary\"\n  [style.--check-secondary]=\"theme?.secondary\"\n></div>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: CheckMarkComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-checkmark', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"hot-toast-checkmark-icon\"\n  [style.--check-primary]=\"theme?.primary\"\n  [style.--check-secondary]=\"theme?.secondary\"\n></div>\n" }]
        }], propDecorators: { theme: [{
                type: Input
            }] } });

class ErrorComponent {
}
ErrorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: ErrorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ErrorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: ErrorComponent, selector: "hot-toast-error", inputs: { theme: "theme" }, ngImport: i0, template: "<div\n  class=\"hot-toast-error-icon\"\n  [style.--error-primary]=\"theme?.primary\"\n  [style.--error-secondary]=\"theme?.secondary\"\n></div>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: ErrorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-error', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"hot-toast-error-icon\"\n  [style.--error-primary]=\"theme?.primary\"\n  [style.--error-secondary]=\"theme?.secondary\"\n></div>\n" }]
        }], propDecorators: { theme: [{
                type: Input
            }] } });

class LoaderComponent {
}
LoaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: LoaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LoaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: LoaderComponent, selector: "hot-toast-loader", inputs: { theme: "theme" }, ngImport: i0, template: "<div\n  class=\"hot-toast-loader-icon\"\n  [ngStyle]=\"{ 'border-color': theme?.primary, 'border-right-color': theme?.secondary }\"\n></div>\n", dependencies: [{ kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: LoaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-loader', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"hot-toast-loader-icon\"\n  [ngStyle]=\"{ 'border-color': theme?.primary, 'border-right-color': theme?.secondary }\"\n></div>\n" }]
        }], propDecorators: { theme: [{
                type: Input
            }] } });

class WarningComponent {
}
WarningComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: WarningComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
WarningComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: WarningComponent, selector: "hot-toast-warning", inputs: { theme: "theme" }, ngImport: i0, template: "<div\n  class=\"hot-toast-warning-icon\"\n  [style.--warn-primary]=\"theme?.primary\"\n  [style.--warn-secondary]=\"theme?.secondary\"\n></div>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: WarningComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-warning', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"hot-toast-warning-icon\"\n  [style.--warn-primary]=\"theme?.primary\"\n  [style.--warn-secondary]=\"theme?.secondary\"\n></div>\n" }]
        }], propDecorators: { theme: [{
                type: Input
            }] } });

class InfoComponent {
}
InfoComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: InfoComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
InfoComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: InfoComponent, selector: "hot-toast-info", inputs: { theme: "theme" }, ngImport: i0, template: "<div\n  class=\"hot-toast-info-icon\"\n  [style.--warn-primary]=\"theme?.primary\"\n  [style.--warn-secondary]=\"theme?.secondary\"\n></div>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: InfoComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-info', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"hot-toast-info-icon\"\n  [style.--warn-primary]=\"theme?.primary\"\n  [style.--warn-secondary]=\"theme?.secondary\"\n></div>\n" }]
        }], propDecorators: { theme: [{
                type: Input
            }] } });

class IndicatorComponent {
}
IndicatorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: IndicatorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
IndicatorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: IndicatorComponent, selector: "hot-toast-indicator", inputs: { theme: "theme", type: "type" }, ngImport: i0, template: "<div *ngIf=\"type !== 'blank'\" class=\"hot-toast-indicator-wrapper\">\n  <hot-toast-loader [theme]=\"theme\"></hot-toast-loader>\n  <div *ngIf=\"type !== 'loading'\" class=\"hot-toast-status-wrapper\">\n    <div [ngSwitch]=\"type\">\n      <div *ngSwitchCase=\"'error'\">\n        <hot-toast-error [theme]=\"theme\"></hot-toast-error>\n      </div>\n      <div *ngSwitchCase=\"'success'\">\n        <hot-toast-checkmark [theme]=\"theme\"></hot-toast-checkmark>\n      </div>\n      <div *ngSwitchCase=\"'warning'\">\n        <hot-toast-warning [theme]=\"theme\"></hot-toast-warning>\n      </div>\n      <div *ngSwitchCase=\"'info'\">\n        <hot-toast-info [theme]=\"theme\"></hot-toast-info>\n      </div>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i1.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "component", type: CheckMarkComponent, selector: "hot-toast-checkmark", inputs: ["theme"] }, { kind: "component", type: ErrorComponent, selector: "hot-toast-error", inputs: ["theme"] }, { kind: "component", type: LoaderComponent, selector: "hot-toast-loader", inputs: ["theme"] }, { kind: "component", type: WarningComponent, selector: "hot-toast-warning", inputs: ["theme"] }, { kind: "component", type: InfoComponent, selector: "hot-toast-info", inputs: ["theme"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: IndicatorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-indicator', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div *ngIf=\"type !== 'blank'\" class=\"hot-toast-indicator-wrapper\">\n  <hot-toast-loader [theme]=\"theme\"></hot-toast-loader>\n  <div *ngIf=\"type !== 'loading'\" class=\"hot-toast-status-wrapper\">\n    <div [ngSwitch]=\"type\">\n      <div *ngSwitchCase=\"'error'\">\n        <hot-toast-error [theme]=\"theme\"></hot-toast-error>\n      </div>\n      <div *ngSwitchCase=\"'success'\">\n        <hot-toast-checkmark [theme]=\"theme\"></hot-toast-checkmark>\n      </div>\n      <div *ngSwitchCase=\"'warning'\">\n        <hot-toast-warning [theme]=\"theme\"></hot-toast-warning>\n      </div>\n      <div *ngSwitchCase=\"'info'\">\n        <hot-toast-info [theme]=\"theme\"></hot-toast-info>\n      </div>\n    </div>\n  </div>\n</div>\n" }]
        }], propDecorators: { theme: [{
                type: Input
            }], type: [{
                type: Input
            }] } });

class HotToastComponent {
    constructor(injector, renderer, ngZone) {
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.offset = 0;
        this.height = new EventEmitter();
        this.beforeClosed = new EventEmitter();
        this.afterClosed = new EventEmitter();
        this.isManualClose = false;
        this.unlisteners = [];
    }
    get containerPositionStyle() {
        const top = this.toast.position.includes('top');
        const verticalStyle = top ? { top: 0 } : { bottom: 0 };
        const horizontalStyle = this.toast.position.includes('left')
            ? {
                left: 0,
            }
            : this.toast.position.includes('right')
                ? {
                    right: 0,
                }
                : {
                    left: 0,
                    right: 0,
                    justifyContent: 'center',
                };
        return {
            transform: `translateY(${this.offset * (top ? 1 : -1)}px)`,
            ...verticalStyle,
            ...horizontalStyle,
        };
    }
    get toastBarBaseStyles() {
        const top = this.toast.position.includes('top');
        const enterAnimation = `hotToastEnterAnimation${top ? 'Negative' : 'Positive'} ${ENTER_ANIMATION_DURATION}ms cubic-bezier(0.21, 1.02, 0.73, 1) forwards`;
        const exitAnimation = `hotToastExitAnimation${top ? 'Negative' : 'Positive'} ${EXIT_ANIMATION_DURATION}ms forwards cubic-bezier(0.06, 0.71, 0.55, 1) ${this.toast.duration}ms`;
        const animation = this.toast.autoClose ? `${enterAnimation}, ${exitAnimation}` : enterAnimation;
        return { ...this.toast.style, animation };
    }
    get isIconString() {
        return typeof this.toast.icon === 'string';
    }
    ngOnInit() {
        if (isTemplateRef(this.toast.message)) {
            this.context = { $implicit: this.toastRef };
        }
        if (isComponent(this.toast.message)) {
            this.toastComponentInjector = Injector.create({
                providers: [
                    {
                        provide: HotToastRef,
                        useValue: this.toastRef,
                    },
                ],
                parent: this.toast.injector || this.injector,
            });
        }
    }
    ngAfterViewInit() {
        const nativeElement = this.toastBarBase.nativeElement;
        // Caretaker note: accessing `offsetHeight` triggers the whole layout update.
        // Macro tasks (like `setTimeout`) might be executed within the current rendering frame and cause a frame drop.
        requestAnimationFrame(() => {
            this.height.emit(nativeElement.offsetHeight);
        });
        // Caretaker note: `animationstart` and `animationend` events are event tasks that trigger change detection.
        // We'd want to trigger the change detection only if it's an exit animation.
        this.ngZone.runOutsideAngular(() => {
            this.unlisteners.push(
            // Caretaker note: we have to remove these event listeners at the end (even if the element is removed from DOM).
            // zone.js stores its `ZoneTask`s within the `nativeElement[Zone.__symbol__('animationstart') + 'false']` property
            // with callback that capture `this`.
            this.renderer.listen(nativeElement, 'animationstart', (event) => {
                if (this.isExitAnimation(event)) {
                    this.ngZone.run(() => this.beforeClosed.emit());
                }
            }), this.renderer.listen(nativeElement, 'animationend', (event) => {
                if (this.isExitAnimation(event)) {
                    this.ngZone.run(() => this.afterClosed.emit({ dismissedByAction: this.isManualClose, id: this.toast.id }));
                }
            }));
        });
        this.setToastAttributes();
    }
    close() {
        this.isManualClose = true;
        const top = this.toast.position.includes('top');
        const exitAnimation = `hotToastExitAnimation${top ? 'Negative' : 'Positive'} ${EXIT_ANIMATION_DURATION}ms forwards cubic-bezier(0.06, 0.71, 0.55, 1)`;
        const nativeElement = this.toastBarBase.nativeElement;
        animate(nativeElement, exitAnimation);
    }
    ngOnDestroy() {
        this.close();
        while (this.unlisteners.length) {
            this.unlisteners.pop()();
        }
    }
    isExitAnimation(ev) {
        return ev.animationName.includes('hotToastExitAnimation');
    }
    setToastAttributes() {
        const toastAttributes = this.toast.attributes;
        for (const [key, value] of Object.entries(toastAttributes)) {
            this.renderer.setAttribute(this.toastBarBase.nativeElement, key, value);
        }
    }
}
HotToastComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastComponent, deps: [{ token: i0.Injector }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
HotToastComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: HotToastComponent, selector: "hot-toast", inputs: { toast: "toast", offset: "offset", defaultConfig: "defaultConfig", toastRef: "toastRef" }, outputs: { height: "height", beforeClosed: "beforeClosed", afterClosed: "afterClosed" }, viewQueries: [{ propertyName: "toastBarBase", first: true, predicate: ["hotToastBarBase"], descendants: true }], ngImport: i0, template: "<div\n  class=\"hot-toast-bar-base-container\"\n  [ngStyle]=\"containerPositionStyle\"\n  [ngClass]=\"'hot-toast-theme-' + toast.theme\"\n>\n  <div\n    class=\"hot-toast-bar-base\"\n    #hotToastBarBase\n    [ngStyle]=\"toastBarBaseStyles\"\n    [ngClass]=\"toast.className\"\n    [style.--hot-toast-animation-state]=\"isManualClose ? 'running' : 'paused'\"\n    [attr.aria-live]=\"toast.ariaLive\"\n    [attr.role]=\"toast.role\"\n  >\n    <div class=\"hot-toast-icon\" aria-hidden=\"true\">\n      <ng-container *ngIf=\"toast.icon !== undefined; else indicator\">\n        <ng-container *ngIf=\"isIconString; else iconTemplateOrComponent\">\n          <hot-toast-animated-icon [iconTheme]=\"toast.iconTheme\">{{ toast.icon }}</hot-toast-animated-icon>\n        </ng-container>\n        <ng-template #iconTemplateOrComponent>\n          <div>\n            <ng-container [dynamicView]=\"toast.icon\"></ng-container>\n          </div>\n        </ng-template>\n      </ng-container>\n\n      <ng-template #indicator>\n        <hot-toast-indicator [theme]=\"toast.iconTheme\" [type]=\"toast.type\"></hot-toast-indicator>\n      </ng-template>\n    </div>\n\n    <div class=\"hot-toast-message\">\n      <div>\n        <ng-container *dynamicView=\"toast.message; context: context; injector: toastComponentInjector\"></ng-container>\n      </div>\n    </div>\n\n    <button\n      *ngIf=\"toast.dismissible\"\n      (click)=\"close()\"\n      type=\"button\"\n      class=\"hot-toast-close-btn\"\n      aria-label=\"Close\"\n      [ngStyle]=\"toast.closeStyle\"\n    ></button>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i1$1.DynamicViewDirective, selector: "[dynamicView]", inputs: ["dynamicView", "dynamicViewInjector", "dynamicViewContext"] }, { kind: "component", type: AnimatedIconComponent, selector: "hot-toast-animated-icon", inputs: ["iconTheme"] }, { kind: "component", type: IndicatorComponent, selector: "hot-toast-indicator", inputs: ["theme", "type"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"hot-toast-bar-base-container\"\n  [ngStyle]=\"containerPositionStyle\"\n  [ngClass]=\"'hot-toast-theme-' + toast.theme\"\n>\n  <div\n    class=\"hot-toast-bar-base\"\n    #hotToastBarBase\n    [ngStyle]=\"toastBarBaseStyles\"\n    [ngClass]=\"toast.className\"\n    [style.--hot-toast-animation-state]=\"isManualClose ? 'running' : 'paused'\"\n    [attr.aria-live]=\"toast.ariaLive\"\n    [attr.role]=\"toast.role\"\n  >\n    <div class=\"hot-toast-icon\" aria-hidden=\"true\">\n      <ng-container *ngIf=\"toast.icon !== undefined; else indicator\">\n        <ng-container *ngIf=\"isIconString; else iconTemplateOrComponent\">\n          <hot-toast-animated-icon [iconTheme]=\"toast.iconTheme\">{{ toast.icon }}</hot-toast-animated-icon>\n        </ng-container>\n        <ng-template #iconTemplateOrComponent>\n          <div>\n            <ng-container [dynamicView]=\"toast.icon\"></ng-container>\n          </div>\n        </ng-template>\n      </ng-container>\n\n      <ng-template #indicator>\n        <hot-toast-indicator [theme]=\"toast.iconTheme\" [type]=\"toast.type\"></hot-toast-indicator>\n      </ng-template>\n    </div>\n\n    <div class=\"hot-toast-message\">\n      <div>\n        <ng-container *dynamicView=\"toast.message; context: context; injector: toastComponentInjector\"></ng-container>\n      </div>\n    </div>\n\n    <button\n      *ngIf=\"toast.dismissible\"\n      (click)=\"close()\"\n      type=\"button\"\n      class=\"hot-toast-close-btn\"\n      aria-label=\"Close\"\n      [ngStyle]=\"toast.closeStyle\"\n    ></button>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { toast: [{
                type: Input
            }], offset: [{
                type: Input
            }], defaultConfig: [{
                type: Input
            }], toastRef: [{
                type: Input
            }], height: [{
                type: Output
            }], beforeClosed: [{
                type: Output
            }], afterClosed: [{
                type: Output
            }], toastBarBase: [{
                type: ViewChild,
                args: ['hotToastBarBase']
            }] } });

class HotToastContainerComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.toasts = [];
        this.toastRefs = [];
        /** Subject for notifying the user that the toast has been closed. */
        this._onClosed = new Subject();
        this.onClosed$ = this._onClosed.asObservable();
    }
    trackById(index, toast) {
        return toast.id;
    }
    calculateOffset(toastId, position) {
        const visibleToasts = this.toasts.filter((t) => t.visible && t.position === position);
        const index = visibleToasts.findIndex((toast) => toast.id === toastId);
        const offset = index !== -1
            ? visibleToasts
                .slice(...(this.defaultConfig.reverseOrder ? [index + 1] : [0, index]))
                .reduce((acc, t) => acc + (t.height || 0) + HOT_TOAST_MARGIN, 0)
            : 0;
        return offset;
    }
    updateHeight(height, toast) {
        toast.height = height;
        this.cdr.detectChanges();
    }
    addToast(ref) {
        this.toastRefs.push(ref);
        const toast = ref.getToast();
        this.toasts.push(ref.getToast());
        this.cdr.detectChanges();
        return {
            dispose: () => {
                this.closeToast(toast.id);
            },
            updateMessage: (message) => {
                toast.message = message;
                this.cdr.detectChanges();
            },
            updateToast: (options) => {
                this.updateToasts(toast, options);
                this.cdr.detectChanges();
            },
            afterClosed: this.getAfterClosed(toast),
        };
    }
    closeToast(id) {
        if (id) {
            const comp = this.hotToastComponentList.find((item) => item.toast.id === id);
            if (comp) {
                comp.close();
            }
        }
        else {
            this.hotToastComponentList.forEach((comp) => comp.close());
        }
    }
    beforeClosed(toast) {
        toast.visible = false;
    }
    afterClosed(closeToast) {
        const toastIndex = this.toasts.findIndex((t) => t.id === closeToast.id);
        if (toastIndex > -1) {
            this._onClosed.next(closeToast);
            this.toasts = this.toasts.filter((t) => t.id !== closeToast.id);
            this.toastRefs = this.toastRefs.filter((t) => t.getToast().id !== closeToast.id);
            this.cdr.detectChanges();
        }
    }
    hasToast(id) {
        return this.toasts.findIndex((t) => t.id === id) > -1;
    }
    getAfterClosed(toast) {
        return this.onClosed$.pipe(filter((v) => v.id === toast.id));
    }
    updateToasts(toast, options) {
        this.toasts = this.toasts.map((t) => ({ ...t, ...(t.id === toast.id && { ...toast, ...options }) }));
    }
}
HotToastContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastContainerComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
HotToastContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.1", type: HotToastContainerComponent, selector: "hot-toast-container", inputs: { defaultConfig: "defaultConfig" }, viewQueries: [{ propertyName: "hotToastComponentList", predicate: HotToastComponent, descendants: true }], ngImport: i0, template: "<div style=\"position: fixed; z-index: 9999; top: 0; right: 0; bottom: 0; left: 0; pointer-events: none\">\n  <div style=\"position: relative; height: 100%\">\n    <hot-toast\n      *ngFor=\"let toast of toasts; trackBy: trackById; let i = index\"\n      [toast]=\"toast\"\n      [offset]=\"calculateOffset(toast.id, toast.position)\"\n      [toastRef]=\"toastRefs[i]\"\n      (height)=\"updateHeight($event, toast)\"\n      (beforeClosed)=\"beforeClosed(toast)\"\n      (afterClosed)=\"afterClosed($event)\"\n    ></hot-toast>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: HotToastComponent, selector: "hot-toast", inputs: ["toast", "offset", "defaultConfig", "toastRef"], outputs: ["height", "beforeClosed", "afterClosed"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, preserveWhitespaces: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastContainerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'hot-toast-container', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div style=\"position: fixed; z-index: 9999; top: 0; right: 0; bottom: 0; left: 0; pointer-events: none\">\n  <div style=\"position: relative; height: 100%\">\n    <hot-toast\n      *ngFor=\"let toast of toasts; trackBy: trackById; let i = index\"\n      [toast]=\"toast\"\n      [offset]=\"calculateOffset(toast.id, toast.position)\"\n      [toastRef]=\"toastRefs[i]\"\n      (height)=\"updateHeight($event, toast)\"\n      (beforeClosed)=\"beforeClosed(toast)\"\n      (afterClosed)=\"afterClosed($event)\"\n    ></hot-toast>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { defaultConfig: [{
                type: Input
            }], hotToastComponentList: [{
                type: ViewChildren,
                args: [HotToastComponent]
            }] } });

class ToastConfig {
    constructor() {
        /**
         * Sets the reverse order for hot-toast stacking
         *
         * @default false
         */
        this.reverseOrder = false;
        this.ariaLive = 'polite';
        this.role = 'status';
        this.position = 'top-center';
        this.autoClose = true;
        this.theme = 'toast';
        this.attributes = {};
        // key in ToastType
        this.info = { content: '' };
        this.success = { content: '' };
        this.error = { content: '' };
        this.loading = { content: '' };
        this.blank = { content: '' };
        this.warning = { content: '' };
    }
}
const isFunction = (valOrFunction) => typeof valOrFunction === 'function';
const resolveValueOrFunction = (valOrFunction, arg) => isFunction(valOrFunction) ? valOrFunction(arg) : valOrFunction;
class ToastPersistConfig {
    constructor() {
        /**
         *In which storage id vs. counts should be stored
         *
         * @type {('local' | 'session')}
         * @memberof ToastPersistConfig
         * @default 'local'
         */
        this.storage = 'local';
        /**
         *The key pattern to store object in storage. `${id}` in pattern is replaced with actual toast id.
         *
         * @type {('local' | 'session')}
         * @memberof ToastPersistConfig
         * @default 'ngneat/hottoast-${id}'
         */
        this.key = 'ngneat/hototast-${id}';
        /**
         *The number of toasts allowed to show.
         *
         * @memberof ToastPersistConfig
         * @default 1
         */
        this.count = 1;
        this.enabled = false;
    }
}

class HotToastService {
    constructor(_viewService, platformId, config) {
        this._viewService = _viewService;
        this.platformId = platformId;
        this._isInitialized = false;
        this._defaultConfig = new ToastConfig();
        this._defaultPersistConfig = new ToastPersistConfig();
        if (config) {
            this._defaultConfig = {
                ...this._defaultConfig,
                ...config,
            };
        }
    }
    get defaultConfig() {
        return this._defaultConfig;
    }
    set defaultConfig(config) {
        this._defaultConfig = {
            ...this._defaultConfig,
            ...config,
        };
        if (this._componentRef) {
            this._componentRef.setInput('defaultConfig', this._defaultConfig);
        }
    }
    /**
     * Opens up an hot-toast without any pre-configurations
     *
     * @param message The message to show in the hot-toast.
     * @param [options] Additional configuration options for the hot-toast.
     * @returns
     * @memberof HotToastService
     */
    show(message, options) {
        const toast = this.createToast(message || this._defaultConfig.blank.content, 'blank', {
            ...this._defaultConfig,
            ...options,
        });
        return toast;
    }
    /**
     * Opens up an hot-toast with pre-configurations for error state
     *
     * @param message The message to show in the hot-toast.
     * @param [options] Additional configuration options for the hot-toast.
     * @returns
     * @memberof HotToastService
     */
    error(message, options) {
        const toast = this.createToast(message || this._defaultConfig.error.content, 'error', {
            ...this._defaultConfig,
            ...this._defaultConfig?.error,
            ...options,
        });
        return toast;
    }
    /**
     * Opens up an hot-toast with pre-configurations for success state
     *
     * @param message The message to show in the hot-toast.
     * @param [options] Additional configuration options for the hot-toast.
     * @returns
     * @memberof HotToastService
     */
    success(message, options) {
        const toast = this.createToast(message || this._defaultConfig.success.content, 'success', {
            ...this._defaultConfig,
            ...this._defaultConfig?.success,
            ...options,
        });
        return toast;
    }
    /**
     * Opens up an hot-toast with pre-configurations for loading state
     *
     * @param message The message to show in the hot-toast.
     * @param [options] Additional configuration options for the hot-toast.
     * @returns
     * @memberof HotToastService
     */
    loading(message, options) {
        const toast = this.createToast(message || this._defaultConfig.loading.content, 'loading', {
            ...this._defaultConfig,
            ...this._defaultConfig?.loading,
            ...options,
        });
        return toast;
    }
    /**
     * Opens up an hot-toast with pre-configurations for warning state
     *
     * @param message The message to show in the hot-toast.
     * @param [options] Additional configuration options for the hot-toast.
     * @returns
     * @memberof HotToastService
     */
    warning(message, options) {
        const toast = this.createToast(message || this._defaultConfig.warning.content, 'warning', {
            ...this._defaultConfig,
            ...this._defaultConfig?.warning,
            ...options,
        });
        return toast;
    }
    /**
     * Opens up an hot-toast with pre-configurations for info state
     *
     * @param message The message to show in the hot-toast.
     * @param [options] Additional configuration options for the hot-toast.
     * @returns
     * @memberof HotToastService
     * @since 3.3.0
     */
    info(message, options) {
        const toast = this.createToast(message || this._defaultConfig.info.content, 'info', {
            ...this._defaultConfig,
            ...this._defaultConfig?.info,
            ...options,
        });
        return toast;
    }
    /**
     *
     *  Opens up an hot-toast with pre-configurations for loading initially and then changes state based on messages
     *
     * @template T Type of observable
     * @param messages Messages for each state i.e. loading, success and error
     * @returns
     * @memberof HotToastService
     */
    observe(messages) {
        return (source) => {
            let toastRef;
            let start = 0;
            const loadingContent = messages.loading ?? this._defaultConfig.loading?.content;
            const successContent = messages.success ?? this._defaultConfig.success?.content;
            const errorContent = messages.error ?? this._defaultConfig.error?.content;
            return defer(() => {
                if (loadingContent) {
                    toastRef = this.createLoadingToast(loadingContent);
                    start = Date.now();
                }
                return source.pipe(tap({
                    ...(successContent && {
                        next: (val) => {
                            toastRef = this.createOrUpdateToast(messages, val, toastRef, 'success', start === 0 ? start : Date.now() - start);
                        },
                    }),
                    ...(errorContent && {
                        error: (e) => {
                            toastRef = this.createOrUpdateToast(messages, e, toastRef, 'error', start === 0 ? start : Date.now() - start);
                        },
                    }),
                }));
            });
        };
    }
    /**
     * Closes the hot-toast
     *
     * @param [id] - ID of the toast
     * @since 3.0.1 - If ID is not provided, all toasts will be closed
     */
    close(id) {
        if (this._componentRef) {
            this._componentRef.ref.instance.closeToast(id);
        }
    }
    /**
     * Used for internal purpose only.
     * Creates a container component and attaches it to document.body.
     */
    init() {
        if (isPlatformServer(this.platformId)) {
            return;
        }
        this._componentRef = this._viewService
            .createComponent(HotToastContainerComponent)
            .setInput('defaultConfig', this._defaultConfig)
            .appendTo(document.body);
    }
    createOrUpdateToast(messages, val, toastRef, type, diff) {
        let content = null;
        let options = {};
        ({ content, options } = this.getContentAndOptions(type, messages[type] || (this._defaultConfig[type] ? this._defaultConfig[type].content : '')));
        content = resolveValueOrFunction(content, val);
        if (toastRef) {
            toastRef.updateMessage(content);
            const updatedOptions = {
                type,
                duration: diff + HOT_TOAST_DEFAULT_TIMEOUTS[type],
                ...options,
                ...(options.duration && { duration: diff + options.duration }),
            };
            toastRef.updateToast(updatedOptions);
        }
        else {
            this.createToast(content, type, options);
        }
        return toastRef;
    }
    createToast(message, type, options, observableMessages) {
        if (!this._isInitialized) {
            this._isInitialized = true;
            this.init();
        }
        const now = Date.now();
        const id = options?.id ?? now.toString();
        if (!this.isDuplicate(id) &&
            (!options.persist?.enabled || (options.persist?.enabled && this.handleStorageValue(id, options)))) {
            const toast = {
                ariaLive: options?.ariaLive ?? 'polite',
                createdAt: now,
                duration: options?.duration ?? HOT_TOAST_DEFAULT_TIMEOUTS[type],
                id,
                message,
                role: options?.role ?? 'status',
                type,
                visible: true,
                observableMessages: observableMessages ?? undefined,
                ...options,
            };
            return new HotToastRef(toast).appendTo(this._componentRef.ref.instance);
        }
    }
    /**
     * Checks whether any toast with same id is present.
     *
     * @private
     * @param id - Toast ID
     */
    isDuplicate(id) {
        return this._componentRef.ref.instance.hasToast(id);
    }
    /**
     * Creates an entry in local or session storage with count ${defaultConfig.persist.count}, if not present.
     * If present in storage, reduces the count
     * and returns the count.
     * Count can not be less than 0.
     */
    handleStorageValue(id, options) {
        let count = 1;
        const persist = { ...this._defaultPersistConfig, ...options.persist };
        const storage = persist.storage === 'local' ? localStorage : sessionStorage;
        const key = persist.key.replace(/\${id}/g, id);
        let item = storage.getItem(key);
        if (item) {
            item = parseInt(item, 10);
            if (item > 0) {
                count = item - 1;
            }
            else {
                count = item;
            }
        }
        else {
            count = persist.count;
        }
        storage.setItem(key, count.toString());
        return count;
    }
    getContentAndOptions(toastType, message) {
        let content;
        let options = {
            ...this._defaultConfig,
            ...this._defaultConfig[toastType],
        };
        // typeof message === 'object' won't work, cz TemplateRef's type is object
        if (typeof message === 'string' || isTemplateRef(message) || isComponent(message)) {
            content = message;
        }
        else {
            let restOptions;
            ({ content, ...restOptions } = message);
            options = { ...options, ...restOptions };
        }
        return { content, options };
    }
    createLoadingToast(messages) {
        let content = null;
        let options = {};
        ({ content, options } = this.getContentAndOptions('loading', messages));
        return this.loading(content, options);
    }
}
HotToastService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastService, deps: [{ token: i1$1.ViewService }, { token: PLATFORM_ID }, { token: ToastConfig, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
HotToastService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1$1.ViewService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: ToastConfig, decorators: [{
                    type: Optional
                }] }]; } });

class HotToastModule {
    static forRoot(config) {
        return {
            ngModule: HotToastModule,
            providers: [{ provide: ToastConfig, useValue: config }],
        };
    }
}
HotToastModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
HotToastModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.1", ngImport: i0, type: HotToastModule, declarations: [HotToastContainerComponent,
        HotToastComponent,
        AnimatedIconComponent,
        IndicatorComponent,
        CheckMarkComponent,
        ErrorComponent,
        LoaderComponent,
        WarningComponent,
        InfoComponent], imports: [CommonModule, DynamicViewModule] });
HotToastModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastModule, imports: [CommonModule, DynamicViewModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: HotToastModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        HotToastContainerComponent,
                        HotToastComponent,
                        AnimatedIconComponent,
                        IndicatorComponent,
                        CheckMarkComponent,
                        ErrorComponent,
                        LoaderComponent,
                        WarningComponent,
                        InfoComponent,
                    ],
                    imports: [CommonModule, DynamicViewModule],
                }]
        }] });

/*
 * Public API Surface of hot-toast
 */

/**
 * Generated bundle index. Do not edit.
 */

export { HotToastModule, HotToastRef, HotToastService, ToastConfig, ToastPersistConfig, resolveValueOrFunction };
//# sourceMappingURL=ngneat-hot-toast.mjs.map
