"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ngAdd = void 0;
/* eslint-disable prefer-arrow/prefer-arrow-functions */
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const utils_1 = require("./utils");
const project_targets_1 = require("./utils/project-targets");
const ng_module_imports_1 = require("./utils/ng-module-imports");
const project_style_file_1 = require("./utils/project-style-file");
const importModuleSet = [
    {
        moduleName: 'HotToastModule',
        importModuleStatement: 'HotToastModule.forRoot()',
        importPath: '@ngneat/hot-toast',
    },
];
const stylesPath = `node_modules/@ngneat/hot-toast/src/styles`;
function ngAdd(options) {
    return (tree) => {
        const workspaceConfig = tree.read('/angular.json');
        if (!workspaceConfig) {
            throw new schematics_1.SchematicsException('Could not find Angular workspace configuration');
        }
        return (0, schematics_1.chain)([
            addPackageJsonDependencies(),
            installPackageJsonDependencies(),
            injectImports(options),
            addModuleToImports(options),
            addHotToastAppStyles(options),
        ]);
    };
}
exports.ngAdd = ngAdd;
function addPackageJsonDependencies() {
    return (host, context) => {
        const dependencies = [{ name: '@ngneat/overview', version: '^3.0.0' }];
        dependencies.forEach((dependency) => {
            (0, utils_1.addPackageToPackageJson)(host, dependency.name, `${dependency.version}`);
            context.logger.log('info', `✅️ Added "${dependency.name}`);
        });
        return host;
    };
}
function installPackageJsonDependencies() {
    return (host, context) => {
        context.addTask(new tasks_1.NodePackageInstallTask());
        context.logger.log('info', `🔍 Installing packages...`);
        return host;
    };
}
function injectImports(options) {
    return (host, context) => {
        if (!options.skipImport) {
            const workspace = (0, utils_1.getWorkspace)(host);
            const project = (0, utils_1.getProjectFromWorkspace)(workspace, options.project ? options.project : Object.keys(workspace.projects)[0]);
            if (!project || project.projectType !== 'application') {
                throw new schematics_1.SchematicsException(`A client project type of "application" is required.`);
            }
            if (!project.architect ||
                !project.architect.build ||
                !project.architect.build.options ||
                !project.architect.build.options.main) {
                throw (0, project_targets_1.targetBuildNotFoundError)();
            }
            const modulePath = (0, ng_ast_utils_1.getAppModulePath)(host, project.architect.build.options.main);
            const moduleSource = (0, utils_1.getSourceFile)(host, modulePath);
            importModuleSet.forEach((item) => {
                if ((0, ast_utils_1.isImported)(moduleSource, item.moduleName, item.importPath)) {
                    context.logger.warn(`Could not import "${item.moduleName}" because it's already imported.`);
                }
                else {
                    const change = (0, ast_utils_1.insertImport)(moduleSource, modulePath, item.moduleName, item.importPath);
                    if (change) {
                        const recorder = host.beginUpdate(modulePath);
                        recorder.insertLeft(change.pos, change.toAdd);
                        host.commitUpdate(recorder);
                        context.logger.log('info', '✅ Written import statement for "' + item.moduleName + '"');
                    }
                }
            });
            return host;
        }
    };
}
function addModuleToImports(options) {
    return (host, context) => {
        if (!options.skipImport) {
            const workspace = (0, utils_1.getWorkspace)(host);
            const project = (0, utils_1.getProjectFromWorkspace)(workspace, options.project ? options.project : Object.keys(workspace.projects)[0]);
            if (!project || project.projectType !== 'application') {
                throw new schematics_1.SchematicsException(`A client project type of "application" is required.`);
            }
            if (!project.architect) {
                throw new schematics_1.SchematicsException(`Architect options not present for project.`);
            }
            if (!project.architect.build) {
                throw new schematics_1.SchematicsException(`Architect:Build options not present for project.`);
            }
            const modulePath = (0, ng_ast_utils_1.getAppModulePath)(host, project.architect.build.options.main);
            importModuleSet.forEach((item) => {
                if ((0, ng_module_imports_1.hasNgModuleImport)(host, modulePath, item.moduleName)) {
                    context.logger.warn(`Could not set up "${item.moduleName}" in "imports[]" because it's already imported.`);
                }
                else {
                    (0, utils_1.addModuleImportToRootModule)(host, item.importModuleStatement, null, project);
                    context.logger.log('info', '✅ Imported "' + item.moduleName + '" in imports');
                }
            });
        }
        return host;
    };
}
/**
 * Adds custom styles to the project style file.
 */
function addHotToastAppStyles(options) {
    return (host, context) => __awaiter(this, void 0, void 0, function* () {
        const workspace = yield (0, utils_1.getWorkspace)(host);
        const project = (0, utils_1.getProjectFromWorkspace)(workspace, options.project ? options.project : Object.keys(workspace.projects)[0]);
        const styleFilePath = (0, project_style_file_1.getProjectStyleFile)(project);
        const logger = context.logger;
        if (!styleFilePath) {
            logger.error(`Could not find the default style file for this project.`);
            logger.info(`Consider manually adding the hot-toast styles to your Application.`);
            return;
        }
        const buffer = host.read(styleFilePath);
        if (!buffer) {
            logger.error(`Could not read the default style file within the project ` + `(${styleFilePath})`);
            logger.info(`Please consider manually setting up the hot-toast styles.`);
            return;
        }
        /** If the file is css then add the styles to the Angular.json else add it to the styles.scss */
        if (styleFilePath.includes('.css')) {
            return insertCSSDependency(options, 'build');
        }
        const htmlContent = buffer.toString();
        const insertion = `@use '${stylesPath}/styles.scss'\n`;
        if (htmlContent.includes(insertion)) {
            return;
        }
        const recorder = host.beginUpdate(styleFilePath);
        recorder.insertLeft(0, insertion);
        host.commitUpdate(recorder);
        context.logger.log('info', '✅ Styles Added to "' + styleFilePath);
    });
}
function insertCSSDependency(options, targetName) {
    return (host, context) => {
        const workspace = (0, utils_1.getWorkspace)(host);
        const project = (0, utils_1.getProjectFromWorkspace)(workspace, options.project ? options.project : Object.keys(workspace.projects)[0]);
        if (!project || project.projectType !== 'application') {
            throw new schematics_1.SchematicsException(`A client project type of "application" is required.`);
        }
        const cssfile = `${stylesPath}/styles.css`;
        (0, utils_1.addStyleToTarget)(project, targetName, host, cssfile, workspace);
        context.logger.log('info', '✅ Styles Imported in angular.json');
        return host;
    };
}
//# sourceMappingURL=index.js.map