/**
 * A storage service implementation that is used as a proxy for another storage service. This is used to create storage services with a
 * different default transcoder.
 */
export class ProxyStorageService {
    /**
     * Creates a new `ProxyStorageService` instance that uses the specified transcoder by default for read and write operations. Actual
     * read and writes are delegated to given storage service.
     *
     * @param defaultTranscoder Transcoder which is to be used by default for storage read and write operations.
     * @param subject           Storage service which should handle to actual storage of data.
     */
    constructor(defaultTranscoder, subject) {
        this.defaultTranscoder = defaultTranscoder;
        this.subject = subject;
    }
    /**
     * Checks whether an entry with the specified key exists in the storage.
     *
     * @param   key Identifier of the entry for which its presence in the storage is to be checked.
     * @returns     `true` if an entry with the specified key exists in the storage, `false` if not.
     */
    has(key) {
        return this.subject.has(key);
    }
    /*
     * Retrieves the value stored for the entry that is associated with the specified key. The given decoder is used to convert the stored
     * value to the desired type. If no entry for the specified key exists or if the decoder is unable to decode the stored value, then
     * `undefined` will be returned.
     *
     * @param   key     Identifier of the entry whose value is to be retrieved.
     * @param   decoder Decoder to use for converting the stored value to the desired return type.
     * @returns         Value of the entry that is identified by the specified key. In case the entry does not exist or if it cannot be
     *                  loaded (due to a decoding issue), then `undefined` will be returned by this function.
     */
    get(key, decoder) {
        return this.subject.get(key, decoder ?? this.defaultTranscoder);
    }
    /**
     * Creates or updates the entry identified by the specified key with the given value. The specified encoder is used to convert the given
     * value into a format that can be stored by the storage service's underlying storage.
     *
     * Storing a value into the storage service will ensure that an equivalent of the value can be read back, i.e. the data and structure of
     * the value will be the same. It, however, does not necessarily return the same reference.
     *
     * @param key     Identifier of the entry which is to be created or updated.
     * @param value   Value which is to be stored.
     * @param encoder Encoder used to convert the given value into a format that can be used for storage.
     */
    set(key, value, encoder) {
        this.subject.set(key, value, encoder ?? this.defaultTranscoder);
    }
    /**
     * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.
     * Attempting to retrieve an entry via the `get` method after it has been removed will result in `undefined`.
     *
     * @param key Identifier of the entry which is to be removed.
     */
    remove(key) {
        this.subject.remove(key);
    }
    /**
     * Clears the storage by removing all entries. Subsequent `get(x)` calls for a key *x* will return `undefined`, until a new value is set
     * for key *x*.
     */
    clear() {
        this.subject.clear();
    }
    /**
     * Creates a new storage service that uses the specified transcoder by default for read and write operations. The new storage service
     * uses the storage service on which this function is invoked as underlying storage. Both storage services will thus be able to access
     * the same data.
     *
     * The default transcoder will not be changed for the storage service on which this function is invoked.
     *
     * @param   transcoder Transcoder that should be used by default for read and write operations by the new storage service.
     * @returns            A new storage service that uses the specified transcoder by default.
     */
    withDefaultTranscoder(transcoder) {
        return new ProxyStorageService(transcoder, this.subject);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJveHktc3RvcmFnZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vbGliL3NyYy9wcm94eS1zdG9yYWdlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0E7OztHQUdHO0FBQ0gsTUFBTSxPQUFPLG1CQUFtQjtJQUU1Qjs7Ozs7O09BTUc7SUFDSCxZQUNxQixpQkFBdUMsRUFDdkMsT0FBdUI7UUFEdkIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFzQjtRQUN2QyxZQUFPLEdBQVAsT0FBTyxDQUFnQjtJQUN4QyxDQUFDO0lBRUw7Ozs7O09BS0c7SUFDSSxHQUFHLENBQUMsR0FBVztRQUNsQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSSxHQUFHLENBQUMsR0FBVyxFQUFFLE9BQTZCO1FBQ2pELE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLE9BQU8sSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEdBQUcsQ0FBQyxHQUFXLEVBQUUsS0FBVSxFQUFFLE9BQTZCO1FBQzdELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxHQUFXO1FBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRDs7O09BR0c7SUFDSSxLQUFLO1FBQ1IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0kscUJBQXFCLENBQUksVUFBZ0M7UUFDNUQsT0FBTyxJQUFJLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDN0QsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RvcmFnZVNlcnZpY2UgfSBmcm9tICcuL3N0b3JhZ2Uuc2VydmljZSc7XG5pbXBvcnQgeyBTdG9yYWdlVHJhbnNjb2RlciwgU3RvcmFnZURlY29kZXIsIFN0b3JhZ2VFbmNvZGVyIH0gZnJvbSAnLi9zdG9yYWdlLXRyYW5zY29kZXInO1xuXG4vKipcbiAqIEEgc3RvcmFnZSBzZXJ2aWNlIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgdXNlZCBhcyBhIHByb3h5IGZvciBhbm90aGVyIHN0b3JhZ2Ugc2VydmljZS4gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBzdG9yYWdlIHNlcnZpY2VzIHdpdGggYVxuICogZGlmZmVyZW50IGRlZmF1bHQgdHJhbnNjb2Rlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFByb3h5U3RvcmFnZVNlcnZpY2U8VD4gaW1wbGVtZW50cyBTdG9yYWdlU2VydmljZTxUPiB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBQcm94eVN0b3JhZ2VTZXJ2aWNlYCBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIHNwZWNpZmllZCB0cmFuc2NvZGVyIGJ5IGRlZmF1bHQgZm9yIHJlYWQgYW5kIHdyaXRlIG9wZXJhdGlvbnMuIEFjdHVhbFxuICAgICAqIHJlYWQgYW5kIHdyaXRlcyBhcmUgZGVsZWdhdGVkIHRvIGdpdmVuIHN0b3JhZ2Ugc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWZhdWx0VHJhbnNjb2RlciBUcmFuc2NvZGVyIHdoaWNoIGlzIHRvIGJlIHVzZWQgYnkgZGVmYXVsdCBmb3Igc3RvcmFnZSByZWFkIGFuZCB3cml0ZSBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSBzdWJqZWN0ICAgICAgICAgICBTdG9yYWdlIHNlcnZpY2Ugd2hpY2ggc2hvdWxkIGhhbmRsZSB0byBhY3R1YWwgc3RvcmFnZSBvZiBkYXRhLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRUcmFuc2NvZGVyOiBTdG9yYWdlVHJhbnNjb2RlcjxUPixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBzdWJqZWN0OiBTdG9yYWdlU2VydmljZSxcbiAgICApIHsgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZW50cnkgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgaW4gdGhlIHN0b3JhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICBrZXkgSWRlbnRpZmllciBvZiB0aGUgZW50cnkgZm9yIHdoaWNoIGl0cyBwcmVzZW5jZSBpbiB0aGUgc3RvcmFnZSBpcyB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm5zICAgICBgdHJ1ZWAgaWYgYW4gZW50cnkgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgaW4gdGhlIHN0b3JhZ2UsIGBmYWxzZWAgaWYgbm90LlxuICAgICAqL1xuICAgIHB1YmxpYyBoYXMoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgc3RvcmVkIGZvciB0aGUgZW50cnkgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuIFRoZSBnaXZlbiBkZWNvZGVyIGlzIHVzZWQgdG8gY29udmVydCB0aGUgc3RvcmVkXG4gICAgICogdmFsdWUgdG8gdGhlIGRlc2lyZWQgdHlwZS4gSWYgbm8gZW50cnkgZm9yIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBpZiB0aGUgZGVjb2RlciBpcyB1bmFibGUgdG8gZGVjb2RlIHRoZSBzdG9yZWQgdmFsdWUsIHRoZW5cbiAgICAgKiBgdW5kZWZpbmVkYCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAga2V5ICAgICBJZGVudGlmaWVyIG9mIHRoZSBlbnRyeSB3aG9zZSB2YWx1ZSBpcyB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHBhcmFtICAgZGVjb2RlciBEZWNvZGVyIHRvIHVzZSBmb3IgY29udmVydGluZyB0aGUgc3RvcmVkIHZhbHVlIHRvIHRoZSBkZXNpcmVkIHJldHVybiB0eXBlLlxuICAgICAqIEByZXR1cm5zICAgICAgICAgVmFsdWUgb2YgdGhlIGVudHJ5IHRoYXQgaXMgaWRlbnRpZmllZCBieSB0aGUgc3BlY2lmaWVkIGtleS4gSW4gY2FzZSB0aGUgZW50cnkgZG9lcyBub3QgZXhpc3Qgb3IgaWYgaXQgY2Fubm90IGJlXG4gICAgICogICAgICAgICAgICAgICAgICBsb2FkZWQgKGR1ZSB0byBhIGRlY29kaW5nIGlzc3VlKSwgdGhlbiBgdW5kZWZpbmVkYCB3aWxsIGJlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgcHVibGljIGdldChrZXk6IHN0cmluZywgZGVjb2Rlcj86IFN0b3JhZ2VEZWNvZGVyPGFueT4pOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJqZWN0LmdldChrZXksIGRlY29kZXIgPz8gdGhpcy5kZWZhdWx0VHJhbnNjb2Rlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciB1cGRhdGVzIHRoZSBlbnRyeSBpZGVudGlmaWVkIGJ5IHRoZSBzcGVjaWZpZWQga2V5IHdpdGggdGhlIGdpdmVuIHZhbHVlLiBUaGUgc3BlY2lmaWVkIGVuY29kZXIgaXMgdXNlZCB0byBjb252ZXJ0IHRoZSBnaXZlblxuICAgICAqIHZhbHVlIGludG8gYSBmb3JtYXQgdGhhdCBjYW4gYmUgc3RvcmVkIGJ5IHRoZSBzdG9yYWdlIHNlcnZpY2UncyB1bmRlcmx5aW5nIHN0b3JhZ2UuXG4gICAgICpcbiAgICAgKiBTdG9yaW5nIGEgdmFsdWUgaW50byB0aGUgc3RvcmFnZSBzZXJ2aWNlIHdpbGwgZW5zdXJlIHRoYXQgYW4gZXF1aXZhbGVudCBvZiB0aGUgdmFsdWUgY2FuIGJlIHJlYWQgYmFjaywgaS5lLiB0aGUgZGF0YSBhbmQgc3RydWN0dXJlIG9mXG4gICAgICogdGhlIHZhbHVlIHdpbGwgYmUgdGhlIHNhbWUuIEl0LCBob3dldmVyLCBkb2VzIG5vdCBuZWNlc3NhcmlseSByZXR1cm4gdGhlIHNhbWUgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAgICAgSWRlbnRpZmllciBvZiB0aGUgZW50cnkgd2hpY2ggaXMgdG8gYmUgY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZSAgIFZhbHVlIHdoaWNoIGlzIHRvIGJlIHN0b3JlZC5cbiAgICAgKiBAcGFyYW0gZW5jb2RlciBFbmNvZGVyIHVzZWQgdG8gY29udmVydCB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIGZvcm1hdCB0aGF0IGNhbiBiZSB1c2VkIGZvciBzdG9yYWdlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnksIGVuY29kZXI/OiBTdG9yYWdlRW5jb2Rlcjxhbnk+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3ViamVjdC5zZXQoa2V5LCB2YWx1ZSwgZW5jb2RlciA/PyB0aGlzLmRlZmF1bHRUcmFuc2NvZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBlbnRyeSB0aGF0IGlzIGlkZW50aWZpZWQgYnkgdGhlIHNwZWNpZmllZCBrZXkuIEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGFuIGVudHJ5IGZvciBhbiB1bmtub3duIGtleSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgICAqIEF0dGVtcHRpbmcgdG8gcmV0cmlldmUgYW4gZW50cnkgdmlhIHRoZSBgZ2V0YCBtZXRob2QgYWZ0ZXIgaXQgaGFzIGJlZW4gcmVtb3ZlZCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgSWRlbnRpZmllciBvZiB0aGUgZW50cnkgd2hpY2ggaXMgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVtb3ZlKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3ViamVjdC5yZW1vdmUoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHN0b3JhZ2UgYnkgcmVtb3ZpbmcgYWxsIGVudHJpZXMuIFN1YnNlcXVlbnQgYGdldCh4KWAgY2FsbHMgZm9yIGEga2V5ICp4KiB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCwgdW50aWwgYSBuZXcgdmFsdWUgaXMgc2V0XG4gICAgICogZm9yIGtleSAqeCouXG4gICAgICovXG4gICAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnN1YmplY3QuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN0b3JhZ2Ugc2VydmljZSB0aGF0IHVzZXMgdGhlIHNwZWNpZmllZCB0cmFuc2NvZGVyIGJ5IGRlZmF1bHQgZm9yIHJlYWQgYW5kIHdyaXRlIG9wZXJhdGlvbnMuIFRoZSBuZXcgc3RvcmFnZSBzZXJ2aWNlXG4gICAgICogdXNlcyB0aGUgc3RvcmFnZSBzZXJ2aWNlIG9uIHdoaWNoIHRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZCBhcyB1bmRlcmx5aW5nIHN0b3JhZ2UuIEJvdGggc3RvcmFnZSBzZXJ2aWNlcyB3aWxsIHRodXMgYmUgYWJsZSB0byBhY2Nlc3NcbiAgICAgKiB0aGUgc2FtZSBkYXRhLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgdHJhbnNjb2RlciB3aWxsIG5vdCBiZSBjaGFuZ2VkIGZvciB0aGUgc3RvcmFnZSBzZXJ2aWNlIG9uIHdoaWNoIHRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHRyYW5zY29kZXIgVHJhbnNjb2RlciB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGRlZmF1bHQgZm9yIHJlYWQgYW5kIHdyaXRlIG9wZXJhdGlvbnMgYnkgdGhlIG5ldyBzdG9yYWdlIHNlcnZpY2UuXG4gICAgICogQHJldHVybnMgICAgICAgICAgICBBIG5ldyBzdG9yYWdlIHNlcnZpY2UgdGhhdCB1c2VzIHRoZSBzcGVjaWZpZWQgdHJhbnNjb2RlciBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIHB1YmxpYyB3aXRoRGVmYXVsdFRyYW5zY29kZXI8WD4odHJhbnNjb2RlcjogU3RvcmFnZVRyYW5zY29kZXI8WD4pOiBTdG9yYWdlU2VydmljZTxYPiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHlTdG9yYWdlU2VydmljZSh0cmFuc2NvZGVyLCB0aGlzLnN1YmplY3QpO1xuICAgIH1cbn1cbiJdfQ==