import { ProxyStorageService } from './proxy-storage.service';
/**
 * Base implementation for storage services.
 */
export class BaseStorageService {
    /**
     * Creates a new `BaseStorageService` that uses the specified transcoder by default for read and write operations.
     *
     * @param defaultTranscoder Transcoder which is to be used by default for storage read and write operations.
     */
    constructor(defaultTranscoder) {
        this.defaultTranscoder = defaultTranscoder;
    }
    /**
     * Retrieves the value stored for the entry that is associated with the specified key. The given decoder is used to convert the stored
     * value to the desired type. If no entry for the specified key exists or if the decoder is unable to decode the stored value, then
     * `undefined` will be returned.
     *
     * @param   key     Identifier of the entry whose value is to be retrieved.
     * @param   decoder Decoder to use for converting the stored value to the desired return type.
     * @returns         Value of the entry that is identified by the specified key. In case the entry does not exist or if it cannot be
     *                  loaded (due to a decoding issue), then `undefined` will be returned by this function.
     */
    get(key, decoder) {
        const value = this.getItem(key);
        return value !== undefined ? (decoder ?? this.defaultTranscoder).decode(value) : undefined;
    }
    /**
     * Creates or updates the entry identified by the specified key with the given value. The specified encoder is used to convert the given
     * value into a format that can be stored by the storage service's underlying storage.
     *
     * Storing a value into the storage service will ensure that an equivalent of the value can be read back, i.e. the data and structure of
     * the value will be the same. It, however, does not necessarily return the same reference.
     *
     * @param key     Identifier of the entry which is to be created or updated.
     * @param value   Value which is to be stored.
     * @param encoder Encoder used to convert the given value into a format that can be used for storage.
     */
    set(key, value, encoder) {
        this.setItem(key, (encoder ?? this.defaultTranscoder).encode(value));
    }
    /**
     * Creates a new storage service that uses the specified transcoder by default for read and write operations. The new storage service
     * uses the storage service on which this function is invoked as underlying storage. Both storage services will thus be able to access
     * the same data.
     *
     * The default transcoder will not be changed for the storage service on which this function is invoked.
     *
     * @param   transcoder Transcoder that should be used by default for read and write operations by the new storage service.
     * @returns            A new storage service that uses the specified transcoder by default.
     */
    withDefaultTranscoder(transcoder) {
        return new ProxyStorageService(transcoder, this);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1zdG9yYWdlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9saWIvc3JjL2Jhc2Utc3RvcmFnZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRTlEOztHQUVHO0FBQ0gsTUFBTSxPQUFnQixrQkFBa0I7SUFFcEM7Ozs7T0FJRztJQUNILFlBQTZCLGlCQUF1QztRQUF2QyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQXNCO0lBQ3BFLENBQUM7SUFVRDs7Ozs7Ozs7O09BU0c7SUFDSSxHQUFHLENBQUMsR0FBVyxFQUFFLE9BQTZCO1FBQ2pELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFaEMsT0FBTyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztJQUMvRixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEdBQUcsQ0FBQyxHQUFXLEVBQUUsS0FBVSxFQUFFLE9BQTZCO1FBQzdELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFnQkQ7Ozs7Ozs7OztPQVNHO0lBQ0kscUJBQXFCLENBQUksVUFBZ0M7UUFDNUQsT0FBTyxJQUFJLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyRCxDQUFDO0NBa0JKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RvcmFnZVNlcnZpY2UgfSBmcm9tICcuL3N0b3JhZ2Uuc2VydmljZSc7XG5pbXBvcnQgeyBTdG9yYWdlRGVjb2RlciwgU3RvcmFnZUVuY29kZXIsIFN0b3JhZ2VUcmFuc2NvZGVyIH0gZnJvbSAnLi9zdG9yYWdlLXRyYW5zY29kZXInO1xuaW1wb3J0IHsgUHJveHlTdG9yYWdlU2VydmljZSB9IGZyb20gJy4vcHJveHktc3RvcmFnZS5zZXJ2aWNlJztcblxuLyoqXG4gKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciBzdG9yYWdlIHNlcnZpY2VzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVN0b3JhZ2VTZXJ2aWNlPFQ+IGltcGxlbWVudHMgU3RvcmFnZVNlcnZpY2U8VD4ge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQmFzZVN0b3JhZ2VTZXJ2aWNlYCB0aGF0IHVzZXMgdGhlIHNwZWNpZmllZCB0cmFuc2NvZGVyIGJ5IGRlZmF1bHQgZm9yIHJlYWQgYW5kIHdyaXRlIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVmYXVsdFRyYW5zY29kZXIgVHJhbnNjb2RlciB3aGljaCBpcyB0byBiZSB1c2VkIGJ5IGRlZmF1bHQgZm9yIHN0b3JhZ2UgcmVhZCBhbmQgd3JpdGUgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRUcmFuc2NvZGVyOiBTdG9yYWdlVHJhbnNjb2RlcjxUPikge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGVudHJ5IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIGluIHRoZSBzdG9yYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtICAga2V5IElkZW50aWZpZXIgb2YgdGhlIGVudHJ5IGZvciB3aGljaCBpdHMgcHJlc2VuY2UgaW4gdGhlIHN0b3JhZ2UgaXMgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJucyAgICAgYHRydWVgIGlmIGFuIGVudHJ5IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIGluIHRoZSBzdG9yYWdlLCBgZmFsc2VgIGlmIG5vdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgaGFzKGtleTogc3RyaW5nKTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgc3RvcmVkIGZvciB0aGUgZW50cnkgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuIFRoZSBnaXZlbiBkZWNvZGVyIGlzIHVzZWQgdG8gY29udmVydCB0aGUgc3RvcmVkXG4gICAgICogdmFsdWUgdG8gdGhlIGRlc2lyZWQgdHlwZS4gSWYgbm8gZW50cnkgZm9yIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBpZiB0aGUgZGVjb2RlciBpcyB1bmFibGUgdG8gZGVjb2RlIHRoZSBzdG9yZWQgdmFsdWUsIHRoZW5cbiAgICAgKiBgdW5kZWZpbmVkYCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAga2V5ICAgICBJZGVudGlmaWVyIG9mIHRoZSBlbnRyeSB3aG9zZSB2YWx1ZSBpcyB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHBhcmFtICAgZGVjb2RlciBEZWNvZGVyIHRvIHVzZSBmb3IgY29udmVydGluZyB0aGUgc3RvcmVkIHZhbHVlIHRvIHRoZSBkZXNpcmVkIHJldHVybiB0eXBlLlxuICAgICAqIEByZXR1cm5zICAgICAgICAgVmFsdWUgb2YgdGhlIGVudHJ5IHRoYXQgaXMgaWRlbnRpZmllZCBieSB0aGUgc3BlY2lmaWVkIGtleS4gSW4gY2FzZSB0aGUgZW50cnkgZG9lcyBub3QgZXhpc3Qgb3IgaWYgaXQgY2Fubm90IGJlXG4gICAgICogICAgICAgICAgICAgICAgICBsb2FkZWQgKGR1ZSB0byBhIGRlY29kaW5nIGlzc3VlKSwgdGhlbiBgdW5kZWZpbmVkYCB3aWxsIGJlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgcHVibGljIGdldChrZXk6IHN0cmluZywgZGVjb2Rlcj86IFN0b3JhZ2VEZWNvZGVyPGFueT4pOiBhbnkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0SXRlbShrZXkpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gKGRlY29kZXIgPz8gdGhpcy5kZWZhdWx0VHJhbnNjb2RlcikuZGVjb2RlKHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9yIHVwZGF0ZXMgdGhlIGVudHJ5IGlkZW50aWZpZWQgYnkgdGhlIHNwZWNpZmllZCBrZXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuIFRoZSBzcGVjaWZpZWQgZW5jb2RlciBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlIGdpdmVuXG4gICAgICogdmFsdWUgaW50byBhIGZvcm1hdCB0aGF0IGNhbiBiZSBzdG9yZWQgYnkgdGhlIHN0b3JhZ2Ugc2VydmljZSdzIHVuZGVybHlpbmcgc3RvcmFnZS5cbiAgICAgKlxuICAgICAqIFN0b3JpbmcgYSB2YWx1ZSBpbnRvIHRoZSBzdG9yYWdlIHNlcnZpY2Ugd2lsbCBlbnN1cmUgdGhhdCBhbiBlcXVpdmFsZW50IG9mIHRoZSB2YWx1ZSBjYW4gYmUgcmVhZCBiYWNrLCBpLmUuIHRoZSBkYXRhIGFuZCBzdHJ1Y3R1cmUgb2ZcbiAgICAgKiB0aGUgdmFsdWUgd2lsbCBiZSB0aGUgc2FtZS4gSXQsIGhvd2V2ZXIsIGRvZXMgbm90IG5lY2Vzc2FyaWx5IHJldHVybiB0aGUgc2FtZSByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5ICAgICBJZGVudGlmaWVyIG9mIHRoZSBlbnRyeSB3aGljaCBpcyB0byBiZSBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHZhbHVlICAgVmFsdWUgd2hpY2ggaXMgdG8gYmUgc3RvcmVkLlxuICAgICAqIEBwYXJhbSBlbmNvZGVyIEVuY29kZXIgdXNlZCB0byBjb252ZXJ0IHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHVzZWQgZm9yIHN0b3JhZ2UuXG4gICAgICovXG4gICAgcHVibGljIHNldChrZXk6IHN0cmluZywgdmFsdWU6IGFueSwgZW5jb2Rlcj86IFN0b3JhZ2VFbmNvZGVyPGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtKGtleSwgKGVuY29kZXIgPz8gdGhpcy5kZWZhdWx0VHJhbnNjb2RlcikuZW5jb2RlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZW50cnkgdGhhdCBpcyBpZGVudGlmaWVkIGJ5IHRoZSBzcGVjaWZpZWQga2V5LiBBdHRlbXB0aW5nIHRvIHJlbW92ZSBhbiBlbnRyeSBmb3IgYW4gdW5rbm93biBrZXkgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKiBBdHRlbXB0aW5nIHRvIHJldHJpZXZlIGFuIGVudHJ5IHZpYSB0aGUgYGdldGAgbWV0aG9kIGFmdGVyIGl0IGhhcyBiZWVuIHJlbW92ZWQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IElkZW50aWZpZXIgb2YgdGhlIGVudHJ5IHdoaWNoIGlzIHRvIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IHJlbW92ZShrZXk6IHN0cmluZyk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHN0b3JhZ2UgYnkgcmVtb3ZpbmcgYWxsIGVudHJpZXMuIFN1YnNlcXVlbnQgYGdldCh4KWAgY2FsbHMgZm9yIGEga2V5ICp4KiB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCwgdW50aWwgYSBuZXcgdmFsdWUgaXMgc2V0XG4gICAgICogZm9yIGtleSAqeCouXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGNsZWFyKCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN0b3JhZ2Ugc2VydmljZSB0aGF0IHVzZXMgdGhlIHNwZWNpZmllZCB0cmFuc2NvZGVyIGJ5IGRlZmF1bHQgZm9yIHJlYWQgYW5kIHdyaXRlIG9wZXJhdGlvbnMuIFRoZSBuZXcgc3RvcmFnZSBzZXJ2aWNlXG4gICAgICogdXNlcyB0aGUgc3RvcmFnZSBzZXJ2aWNlIG9uIHdoaWNoIHRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZCBhcyB1bmRlcmx5aW5nIHN0b3JhZ2UuIEJvdGggc3RvcmFnZSBzZXJ2aWNlcyB3aWxsIHRodXMgYmUgYWJsZSB0byBhY2Nlc3NcbiAgICAgKiB0aGUgc2FtZSBkYXRhLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgdHJhbnNjb2RlciB3aWxsIG5vdCBiZSBjaGFuZ2VkIGZvciB0aGUgc3RvcmFnZSBzZXJ2aWNlIG9uIHdoaWNoIHRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHRyYW5zY29kZXIgVHJhbnNjb2RlciB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGRlZmF1bHQgZm9yIHJlYWQgYW5kIHdyaXRlIG9wZXJhdGlvbnMgYnkgdGhlIG5ldyBzdG9yYWdlIHNlcnZpY2UuXG4gICAgICogQHJldHVybnMgICAgICAgICAgICBBIG5ldyBzdG9yYWdlIHNlcnZpY2UgdGhhdCB1c2VzIHRoZSBzcGVjaWZpZWQgdHJhbnNjb2RlciBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIHB1YmxpYyB3aXRoRGVmYXVsdFRyYW5zY29kZXI8WD4odHJhbnNjb2RlcjogU3RvcmFnZVRyYW5zY29kZXI8WD4pOiBTdG9yYWdlU2VydmljZTxYPiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHlTdG9yYWdlU2VydmljZSh0cmFuc2NvZGVyLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgYWN0dWFsIHJldHJpZXZhbCBvZiBhIHZhbHVlIGZyb20gc3RvcmFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIGtleSBJZGVudGlmaWVyIG9mIHRoZSBlbnRyeSB3aG9zZSB2YWx1ZSBpcyB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybnMgICAgIFRoZSB2YWx1ZSB0aGF0IGlzIHN0b3JlZCBmb3IgdGhlIHNwZWNpZmllZCBlbnRyeSBvciBgdW5kZWZpbmVkYCBpZiBubyBlbnRyeSBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBwcm92aWRlZCB2YWx1ZSB1c2luZyBzcGVjaWZpZWQga2V5IGluIHRoZSBzdG9yYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAgIElkZW50aWZpZXIgb2YgdGhlIGVudHJ5IGZvciB3aGljaCB0aGUgdmFsdWUgaXMgdG8gYmUgc3RvcmVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzdG9yZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xuXG59XG4iXX0=